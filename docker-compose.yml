version: '3'
services:

  ### DB START
  # This is the database to which the all the other components in the stack will connect and interact with
  # (but mostly it's PostgREST that is going to be responsible for the bulk of the db traffic)
  # Having the database in a container is very convenient in development but in production you will
  # use a separate database instance, like Amazon RDS, i.e. in production this section will be
  # commented and in the .env file you will specify the ip of your separate database instance
  db:
    image: postgres:${PG_VERSION}
    ports:
      - "5432:5432"
    environment:
      # env vars specific to postgres image used on first boot
      - POSTGRES_USER=${SUPER_USER}
      - POSTGRES_PASSWORD=${SUPER_USER_PASSWORD}
      - POSTGRES_DB=${DB_NAME}
      # env vars useful for our sql scripts
      - SUPER_USER=${SUPER_USER}
      - SUPER_USER_PASSWORD=${SUPER_USER_PASSWORD}
      - DB_NAME=${DB_NAME}
      - DB_USER=${DB_USER}
      - DB_PASS=${DB_PASS}
      - DB_ANON_ROLE=${DB_ANON_ROLE}
      - DEVELOPMENT=${DEVELOPMENT}
      - JWT_SECRET=${JWT_SECRET}
    volumes:
      - "./db/src:/docker-entrypoint-initdb.d"
    networks:
      frontapp:
        ipv4_address: 172.25.0.2
  ### DB END

  # PostgREST instance, is responsible for communicating with the database
  # and providing a REST api, (almost) every request that is sent to the database goes through it
  postgrest:
    image: postgrest/postgrest
    ports:
      - "3000:3000"
    links:
      - db:db
    environment:
      - PGRST_DB_URI=postgres://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}
      - PGRST_DB_SCHEMA=${DB_SCHEMA} 
      - PGRST_DB_ANON_ROLE=${DB_ANON_ROLE}
      - PGRST_DB_POOL=${DB_POOL} 
      - PGRST_JWT_SECRET=${JWT_SECRET}  
      - PGRST_MAX_ROWS=${MAX_ROWS} 
      - PGRST_PRE_REQUEST=${PRE_REQUEST}
      - PGRST_SERVER_PROXY_URI=${SERVER_PROXY_URI}
    networks:
      frontapp:
        ipv4_address: 172.25.0.3
    depends_on:
      - db

  # OpenResty (Nginx + Lua) instance that sits in front of PostgREST.
  # All the requests coming into the system are first hitting this component.
  # After some processing/checks and transformation, the request is forwarded
  # to PostgREST down the stack.
  openresty:
    image: openresty/openresty:stretch
    command: ["/usr/bin/openresty", "-g", "daemon off; error_log /dev/stderr info;"]
    ports:
      - "8080:80"
    links:
      - db:db
      - postgrest:postgrest
    environment:
      - JWT_SECRET=${JWT_SECRET}
      - DEVELOPMENT=${DEVELOPMENT}
      - POSTGREST_HOST=${POSTGREST_HOST}
      - POSTGREST_PORT=${POSTGREST_PORT}
      - DB_HOST=${DB_HOST}
      - DB_PORT=${DB_PORT}
      - DB_NAME=${DB_NAME}
      - DB_SCHEMA=${DB_SCHEMA}
      - DB_USER=${DB_USER}
      - DB_PASS=${DB_PASS}
    volumes:
      - "./openresty/nginx:/usr/local/openresty/nginx/conf"
      - "./openresty/html:/usr/local/openresty/nginx/html"
      - "./openresty/lua:/usr/local/openresty/lualib/user_code"
    networks:
      frontapp:
        ipv4_address: 172.25.0.4
    depends_on:
      - postgrest

  # pg-amqp-bridge instance is responsible for forwarding NOTIFY events in PostgreSQL
  # to RabbitMQ based on the BRIDGE_CHANNELS configuration
  pg_amqp_bridge:
    image: kibatic/pg-amqp-bridge
    links:
      - db
      - rabbitmq
    environment:
      - RUST_LOG=info # output forwarded messages
      - POSTGRESQL_URI=postgres://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}
      - AMQP_URI=amqp://${RABBITMQ_DEFAULT_USER}:${RABBITMQ_DEFAULT_PASS}@rabbitmq//
      - BRIDGE_CHANNELS=events:amq.topic
    networks:
      frontapp:
        ipv4_address: 172.25.0.5
    depends_on:
      - db

  # RabbitMQ instance can be used to consolidate events that originated in your database/application.
  # You can connect here with different consumers and take actions based on those events (like sending signup emails)
  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5671:5671"
      - "5672:5672"
      - "15672:15672"
    environment:
      - RABBITMQ_DEFAULT_USER=${RABBITMQ_DEFAULT_USER}
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_DEFAULT_PASS}
    networks:
      frontapp:
        ipv4_address: 172.25.0.6

  swagger:
    image: swaggerapi/swagger-ui
    ports:
      - "8081:8080"
    expose:
      - "8081"
    depends_on: 
      - openresty
    environment:
      API_URL: http://localhost:8080/rest/
    networks:
      frontapp:
        ipv4_address: 172.25.0.7

  pgadmin:
    image: dpage/pgadmin4
    ports:
      - "8082:80"
    expose:
      - "8082"
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD}
    volumes:
      - pgadmin-data:/var/lib/pgadmin
    networks:
      frontapp:
        ipv4_address: 172.25.0.8

volumes:
  pgadmin-data:

# https://stackoverflow.com/questions/37242217/access-docker-container-from-host-using-containers-name
networks:
  frontapp:
    driver: bridge
    ipam:
      driver: default
      config:
        - subnet: 172.25.0.0/16
          gateway: 172.25.0.1
